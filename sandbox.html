<!DOCTYPE html>
<html>
<head>
    <title>Денис Казаков, гений МММ | 2D Sandbox Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* CSS для оформления страницы */
        body { 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            background-color: #222; 
            font-family: sans-serif;
            color: white;
            flex-direction: column;
        }
        .nav-bar { 
            background-color: #333; 
            padding: 10px 0; 
            margin-bottom: 20px; 
            width: 100%;
            text-align: center;
        }
        .nav-bar a { 
            color: #fff; 
            padding: 14px 20px; 
            text-decoration: none; 
            font-size: 18px; 
            font-weight: bold; 
        }
        .nav-bar a:hover { 
            background-color: #575757; 
        }
        canvas { 
            border: 4px solid #000; 
            background-color: #87CEEB; /* Небо */ 
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        .controls { 
            margin: 10px 0; 
            text-align: center;
        }
        .controls p { 
            margin: 5px 0; 
            font-size: 0.9em;
        }
        #inventory-display {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border-radius: 8px;
            z-index: 10;
        }
        .slot {
            width: 70px; 
            height: 50px;
            border: 2px solid #555;
            margin: 0 3px;
            text-align: center;
            font-size: 1em;
            font-weight: bold;
            box-sizing: border-box;
            background-color: #333;
            color: white;
            position: relative;
        }
        .slot.active {
            border-color: yellow;
            box-shadow: 0 0 10px yellow;
        }
        .slot-count {
            position: absolute;
            bottom: 0px;
            right: 2px;
            font-size: 0.8em;
            background: rgba(0, 0, 0, 0.5);
            padding: 0 2px;
            border-radius: 3px;
        }

        /* --- МОБИЛЬНАЯ АДАПТАЦИЯ --- */
        @media (max-width: 850px) {
            h2 { font-size: 1.2em; }
            .controls p { font-size: 0.8em; }
            
            canvas { 
                max-width: 95vw;
                height: auto; 
            }
            
            /* Уменьшаем инвентарь */
            .slot {
                width: 50px; 
                height: 40px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="nav-bar">
        <a href="index.html">Главная</a>
        <a href="games.html">Игры</a>
        <a href="about.html">Автор</a>
    </div>
    
    <h2>Денис Казаков, гений МММ, представляет 2D Сэндбокс!</h2>
    <div class="controls">
        <p>Управление: **A/D** (Движение), **W/Space** (Прыжок) | Инвентарь: **1, 2, 3**</p>
        <p>Интеракция: **Левый клик** (Разместить), **Правый клик** (Удалить)</p>
    </div>
    <div id="inventory-display"></div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        window.onload = function() {
            
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const invDisplay = document.getElementById('inventory-display');
            let lastTime = 0;

            const SCREEN_WIDTH = canvas.width;
            const SCREEN_HEIGHT = canvas.height;
            const TILE_SIZE = 40; 
            const WORLD_COLS = 150; 
            const WORLD_ROWS = 80;
            const GROUND_LEVEL = Math.floor(WORLD_ROWS * 0.4); 
            const GRAVITY = 9.8 * TILE_SIZE * 0.5;

            const TILES = { AIR: 0, GRASS: 1, WOOD: 2, STONE: 3, LEAF: 4 };
            const SOLID_TILES = [TILES.GRASS, TILES.WOOD, TILES.STONE, TILES.LEAF]; 
            const COLLECTIBLE_TILES = [TILES.GRASS, TILES.WOOD, TILES.STONE]; 
            const COLORS = {
                [TILES.AIR]: 'rgba(0, 0, 0, 0)', [TILES.GRASS]: '#4CAF50', [TILES.WOOD]: '#A0522D',
                [TILES.STONE]: '#757575', [TILES.LEAF]: '#2ECC71'
            };
            const TILE_NAMES = {
                [TILES.GRASS]: 'Трава', [TILES.WOOD]: 'Дерево',
                [TILES.STONE]: 'Камень', [TILES.LEAF]: 'Листва'
            };

            let player = {
                x: TILE_SIZE * 5,
                y: TILE_SIZE * 5, 
                width: TILE_SIZE * 0.8,
                height: TILE_SIZE * 1.8,
                vx: 0, vy: 0, 
                speed: TILE_SIZE * 5, 
                jumpVelocity: -TILE_SIZE * 10, 
                isGrounded: false
            };
            
            let camera = { x: 0, y: 0 };

            let inventory = {
                slots: [
                    { type: TILES.GRASS, count: 50, maxStack: 99 },
                    { type: TILES.WOOD, count: 50, maxStack: 99 },
                    { type: TILES.STONE, count: 50, maxStack: 99 }
                ],
                activeIndex: 0 
            };
            
            class Slime {
                constructor(x, y) {
                    this.x = x; this.y = y;
                    this.width = TILE_SIZE * 0.8; this.height = TILE_SIZE * 0.8;
                    this.vx = 0; this.vy = 0;
                    this.speed = TILE_SIZE * 2;
                    this.isGrounded = false;
                    this.color = '#3498DB';
                    this.jumpTimer = 0;
                    this.jumpInterval = Math.random() * 2 + 1;
                }

                update(dt) {
                    this.isGrounded = false; 
                    this.vx = Math.sin(this.x / (TILE_SIZE * 5)) * this.speed * 0.5;
                    this.jumpTimer += dt;
                    if (this.jumpTimer >= this.jumpInterval && this.isGrounded) {
                        this.vy = -TILE_SIZE * 10;
                        this.isGrounded = false;
                        this.jumpTimer = 0;
                        this.jumpInterval = Math.random() * 2 + 1;
                    }
                    this.vy += GRAVITY * dt;
                    
                    this.checkAndResolveCollision(dt);
                }
                
                checkAndResolveCollision(dt) {
                    this.isGrounded = false;

                    let newX = this.x + this.vx * dt;
                    let collisionX = checkCollision(newX, this.y, this.width, this.height);
                    if (collisionX.length === 0) {
                        this.x = newX;
                    } else {
                        if (this.vx > 0) this.x = collisionX[0][0] * TILE_SIZE - this.width;
                        else if (this.vx < 0) this.x = collisionX[0][0] * TILE_SIZE + TILE_SIZE;
                        
                        if (Math.abs(this.vx) < 0.1) {
                            this.vx = (Math.random() > 0.5 ? 1 : -1) * this.speed * 0.5;
                        } else {
                            this.vx *= -1;
                        }
                    }

                    let newY = this.y + this.vy * dt;
                    let collisionY = checkCollision(this.x, newY, this.width, this.height);
                    
                    if (collisionY.length === 0) {
                        this.y = newY;
                    } else {
                        if (this.vy > 0) { 
                            this.y = collisionY[0][1] * TILE_SIZE - this.height;
                            this.isGrounded = true;
                        } else if (this.vy < 0) { 
                            this.y = collisionY[0][1] * TILE_SIZE + TILE_SIZE;
                        }
                        this.vy = 0;
                    }
                }

                draw() {
                    const screenX = this.x - camera.x;
                    const screenY = this.y - camera.y;

                    ctx.fillStyle = this.color; 
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(screenX, screenY, this.width, this.height);
                }
            }

            let entities = [];

            let world = [];
            function generateWorld() {
                for (let y = 0; y < WORLD_ROWS; y++) { world[y] = Array(WORLD_COLS).fill(TILES.AIR); }

                let height = GROUND_LEVEL;
                for (let x = 0; x < WORLD_COLS; x++) {
                    height += Math.floor(Math.random() * 3) - 1; 
                    height = Math.max(GROUND_LEVEL - 5, Math.min(GROUND_LEVEL + 5, height));

                    for (let y = height; y < WORLD_ROWS; y++) {
                        if (y === height) {
                            world[y][x] = TILES.GRASS;
                        } else if (y < height + 5) {
                            world[y][x] = TILES.STONE; 
                        } else {
                            if (Math.random() < 0.9) {
                                world[y][x] = TILES.STONE;
                            }
                        }
                    }
                }
                
                for (let x = 5; x < WORLD_COLS - 5; x += 10) {
                    if (Math.random() < 0.6) {
                        let surfaceY = -1;
                        for(let y=0; y < WORLD_ROWS; y++) {
                            if (world[y][x] === TILES.GRASS) {
                                surfaceY = y;
                                break;
                            }
                        }
                        if (surfaceY > 0) {
                            const treeHeight = Math.floor(Math.random() * 3) + 3;
                            for (let h = 0; h < treeHeight; h++) {
                                const treeY = surfaceY - 1 - h;
                                if (treeY >= 0 && world[treeY][x] === TILES.AIR) {
                                    world[treeY][x] = TILES.WOOD;
                                }
                            }
                            const leafY = surfaceY - treeHeight - 1;
                            for (let r = -2; r <= 2; r++) {
                                for (let c = -2; c <= 2; c++) {
                                    if (x + c >= 0 && x + c < WORLD_COLS && leafY + r >= 0 && leafY + r < WORLD_ROWS) {
                                        if (Math.abs(r) + Math.abs(c) < 4 && world[leafY + r][x + c] === TILES.AIR) {
                                            world[leafY + r][x + c] = TILES.LEAF;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                entities.push(new Slime(TILE_SIZE * 50, TILE_SIZE * 10));
            }

            function checkCollision(x, y, w, h) {
                const tiles = [];
                const x1 = Math.floor(x / TILE_SIZE);
                const y1 = Math.floor(y / TILE_SIZE);
                const x2 = Math.floor((x + w - 0.001) / TILE_SIZE); 
                const y2 = Math.floor((y + h - 0.001) / TILE_SIZE); 

                for (let r = y1; r <= y2; r++) {
                    for (let c = x1; c <= x2; c++) {
                        if (r >= 0 && r < WORLD_ROWS && c >= 0 && c < WORLD_COLS && SOLID_TILES.includes(world[r][c])) {
                            tiles.push([c, r]); 
                        }
                    }
                }
                return tiles;
            }
            
            function checkIsGrounded() {
                const groundTolerance = 2; 
                const tilesBelow = checkCollision(
                    player.x, 
                    player.y + player.height, 
                    player.width, 
                    groundTolerance
                );
                return tilesBelow.length > 0;
            }


            function resolvePlayerCollision(dt) {
                let newX = player.x + player.vx * dt;
                let collisionX = checkCollision(newX, player.y, player.width, player.height);
                
                if (collisionX.length === 0) {
                    player.x = newX;
                } else {
                    if (player.vx > 0) { 
                        player.x = collisionX[0][0] * TILE_SIZE - player.width;
                    } else if (player.vx < 0) { 
                        player.x = collisionX[0][0] * TILE_SIZE + TILE_SIZE;
                    }
                    player.vx = 0;
                }

                let newY = player.y + player.vy * dt;
                let collisionY = checkCollision(player.x, newY, player.width, player.height);
                
                if (collisionY.length === 0) {
                    player.y = newY;
                } else {
                    if (player.vy > 0) { 
                        player.y = collisionY[0][1] * TILE_SIZE - player.height;
                    } else if (player.vy < 0) { 
                        player.y = collisionY[0][1] * TILE_SIZE + TILE_SIZE;
                    }
                    player.vy = 0; 
                }
            }

            function update(dt) {
                player.vx = 0;
                
                if (keys.A) { player.vx = -player.speed; }
                if (keys.D) { player.vx = player.speed; }
                
                if ((keys.W || keys.SPACE) && player.isGrounded) {
                    player.vy = player.jumpVelocity;
                    player.isGrounded = false;
                }

                player.vy += GRAVITY * dt;
                
                resolvePlayerCollision(dt);

                entities.forEach(entity => entity.update(dt));

                player.x = Math.max(0, Math.min(WORLD_COLS * TILE_SIZE - player.width, player.x));
                player.y = Math.max(0, player.y); 

                camera.x = player.x - SCREEN_WIDTH / 2 + player.width / 2;
                camera.y = player.y - SCREEN_HEIGHT / 2 + player.height / 2;

                camera.x = Math.max(0, Math.min(camera.x, WORLD_COLS * TILE_SIZE - SCREEN_WIDTH));
                camera.y = Math.max(0, Math.min(camera.y, WORLD_ROWS * TILE_SIZE - SCREEN_HEIGHT));
                
                player.isGrounded = checkIsGrounded(); 
            }

            function findSlot(tileType) {
                if (!COLLECTIBLE_TILES.includes(tileType)) return null; 
                return inventory.slots.find(slot => slot.type === tileType);
            }

            function updateInventoryDisplay() {
                invDisplay.innerHTML = ''; 
                inventory.slots.forEach((slot, index) => {
                    const div = document.createElement('div');
                    div.className = 'slot';
                    div.textContent = TILE_NAMES[slot.type] || '???';
                    div.style.backgroundColor = COLORS[slot.type];
                    
                    if (index === inventory.activeIndex) {
                        div.classList.add('active');
                    } else {
                        div.classList.remove('active');
                    }
                    
                    const countSpan = document.createElement('span');
                    countSpan.className = 'slot-count';
                    countSpan.textContent = slot.count;
                    div.appendChild(countSpan);
                    
                    invDisplay.appendChild(div);
                });
            }
            
            function drawWorld() {
                const startCol = Math.floor(camera.x / TILE_SIZE);
                const endCol = Math.ceil((camera.x + SCREEN_WIDTH) / TILE_SIZE);
                const startRow = Math.floor(camera.y / TILE_SIZE);
                const endRow = Math.ceil((camera.y + SCREEN_HEIGHT) / TILE_SIZE);

                for (let y = startRow; y < endRow; y++) {
                    for (let x = startCol; x < endCol; x++) {
                        if (y >= 0 && y < WORLD_ROWS && x >= 0 && x < WORLD_COLS) {
                            const tileType = world[y][x];
                            
                            if (tileType !== TILES.AIR) {
                                ctx.fillStyle = COLORS[tileType];
                                const screenX = x * TILE_SIZE - camera.x;
                                const screenY = y * TILE_SIZE - camera.y;

                                ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                                
                                ctx.strokeStyle = '#333';
                                ctx.strokeRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                            }
                        }
                    }
                }
            }

            function drawPlayer() {
                ctx.fillStyle = player.isGrounded ? '#0099ff' : '#00ffff'; 
                
                const screenX = player.x - camera.x;
                const screenY = player.y - camera.y;

                ctx.fillRect(screenX, screenY, player.width, player.height);
                ctx.strokeStyle = '#000';
                ctx.strokeRect(screenX, screenY, player.width, player.height);
            }
            
            function gameLoop(timestamp) {
                if (!lastTime) lastTime = timestamp;
                const dt = (timestamp - lastTime) / 1000;
                lastTime = timestamp;

                ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                
                update(dt);

                drawWorld();
                entities.forEach(entity => entity.draw()); 
                drawPlayer();
                
                requestAnimationFrame(gameLoop);
            }

            function handleMouseAction(event, action) {
                const rect = canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;
                
                const worldX = clickX + camera.x;
                const worldY = clickY + camera.y;

                const col = Math.floor(worldX / TILE_SIZE);
                const row = Math.floor(worldY / TILE_SIZE);

                if (row >= 0 && row < WORLD_ROWS && col >= 0 && col < WORLD_COLS) {
                    const isOccupiedByPlayer = (col >= Math.floor(player.x / TILE_SIZE) && col <= Math.floor((player.x + player.width - 1) / TILE_SIZE) &&
                                                row >= Math.floor(player.y / TILE_SIZE) && row <= Math.floor((player.y + player.height - 1) / TILE_SIZE));
                    
                    if (isOccupiedByPlayer) { return; }

                    if (action === 'place') {
                        const activeSlot = inventory.slots[inventory.activeIndex];
                        if (world[row][col] === TILES.AIR && activeSlot.count > 0) { 
                            world[row][col] = activeSlot.type;
                            activeSlot.count--; 
                            updateInventoryDisplay();
                        }
                    } else if (action === 'destroy') {
                        const blockType = world[row][col];
                        if (blockType !== TILES.AIR) { 
                            const slot = findSlot(blockType);
                            
                            if (slot && slot.count < slot.maxStack) {
                                slot.count++;
                                world[row][col] = TILES.AIR; 
                                updateInventoryDisplay();
                            } else if (!slot) {
                                world[row][col] = TILES.AIR; 
                            }
                        }
                    }
                }
            }

            canvas.addEventListener('click', (event) => { handleMouseAction(event, 'place'); });
            canvas.addEventListener('contextmenu', (event) => {
                event.preventDefault(); 
                handleMouseAction(event, 'destroy');
            });
            
            const keys = { A: false, D: false, W: false, SPACE: false };
            
            document.addEventListener('keydown', (e) => {
                const key = e.key.toUpperCase();
                if (key === 'A') keys.A = true;
                if (key === 'D') keys.D = true;
                
                if (key === 'W' || key === ' ') { 
                    keys.W = true;
                    keys.SPACE = true;
                }
                
                if (key >= '1' && key <= '3') {
                    const index = parseInt(key) - 1;
                    if (index < inventory.slots.length) {
                        inventory.activeIndex = index;
                        updateInventoryDisplay();
                    }
                }
            });
            document.addEventListener('keyup', (e) => {
                const key = e.key.toUpperCase();
                if (key === 'A') keys.A = false;
                if (key === 'D') keys.D = false;
                
                if (key === 'W' || key === ' ') { 
                    keys.W = false;
                    keys.SPACE = false;
                }
            });

            generateWorld();
            updateInventoryDisplay();
            gameLoop(0); 
        }
    </script>
</body>
</html>
